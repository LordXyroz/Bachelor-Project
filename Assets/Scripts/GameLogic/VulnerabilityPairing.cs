using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Static class for holding which attack is stopped by which defense.
/// Uses Dictionary with a list to create a one-to-many relationship
/// </summary>

public static class VulnerabilityPairings
{
    private static Dictionary<AttackTypes, List<DefenseTypes>> _vulnerabilityPairs;

    /// <summary>
    /// Static constructor for setting up default values of the dictionary
    /// AttackTypes is the key, List of DefenseTypes is the value
    /// </summary>
    static VulnerabilityPairings()
    {
        _vulnerabilityPairs = new Dictionary<AttackTypes, List<DefenseTypes>>
        {
            { AttackTypes.Injection,               new List<DefenseTypes> { DefenseTypes.Sanitize_Input, DefenseTypes.Use_Safe_API } },
            { AttackTypes.Credential_Stuffing,     new List<DefenseTypes> { DefenseTypes.Two_Factor_Auth, DefenseTypes.Enforce_PW_Policy } },
            { AttackTypes.Package_Sniffing,        new List<DefenseTypes> { DefenseTypes.Firewall, DefenseTypes.Encrypt_Data } },
            { AttackTypes.Hostile_XML,             new List<DefenseTypes> { DefenseTypes.Sanitize_Input, DefenseTypes.Patch_Update } },
            { AttackTypes.Bypass_Access_Control,   new List<DefenseTypes> { DefenseTypes.Log_Failure, DefenseTypes.Off_Site_Logging } },
            { AttackTypes.Exploit_Sec_Mis_Config,  new List<DefenseTypes> { DefenseTypes.Update_Config, DefenseTypes.Reduce_Unused_Features } },
            { AttackTypes.XSS,                     new List<DefenseTypes> { DefenseTypes.Esacpe_Untrusted_HTTP, DefenseTypes.Sanitize_Input } },
            { AttackTypes.Remote_Code_Exec,        new List<DefenseTypes> { DefenseTypes.Integrity_Check, DefenseTypes.Log_Failure } },
            { AttackTypes.Mis_Config_Systems,      new List<DefenseTypes> { DefenseTypes.Reduce_Unused_Features, DefenseTypes.Patch_Update } },
            { AttackTypes.Disable_Log,             new List<DefenseTypes> { DefenseTypes.Off_Site_Logging, DefenseTypes.Patch_Update } }   

        };
    }

    /// <summary>
    /// Checks whether the attack is stopped by the defense.
    /// Throws an exception if the dictionary doesn't contain the attack.
    /// </summary>
    /// <param name="attack">Type of attack</param>
    /// <param name="defense">Type of defense</param>
    /// <returns>True if the defense stops the attack, else false</returns>
    public static bool IsStoppedBy(AttackTypes attack, DefenseTypes defense)
    {
        if (!_vulnerabilityPairs.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _vulnerabilityPairs[attack].Contains(defense);
    }
}

