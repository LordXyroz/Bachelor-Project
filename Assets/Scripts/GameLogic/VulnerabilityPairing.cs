using UnityEngine;
using System.Collections.Generic;
using System.IO;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Linq;

/// <summary>
/// Static class for holding which attack is stopped by which defense.
/// Uses Dictionary with a list to create a one-to-many relationship
/// </summary>
/// 
/// TODO:
/// Try-catch for typos etc...
public static class VulnerabilityPairings
{
    private static Dictionary<AttackTypes, List<DefenseTypes>> _vulnerabilityPairs;

    private static Dictionary<AttackTypes, string> _attackStringValue;
    private static Dictionary<DefenseTypes, string> _defenseStringValue;

    private static List<AttackTypes> _attacks;
    private static List<DefenseTypes> _defenses;

    /// <summary>
    /// Static constructor for setting up default values of the dictionary.
    /// AttackTypes is the key, List of DefenseTypes is the value.
    /// Loads xml file, and parses its content. Uses TryParse from enum
    /// to match the string value from xml with an enum entry.
    /// </summary>
    static VulnerabilityPairings()
    {
        _vulnerabilityPairs = new Dictionary<AttackTypes, List<DefenseTypes>>();
        _attacks = new List<AttackTypes>();
        _defenses = new List<DefenseTypes>();

        using (var r = XmlReader.Create("Assets/Resources/vulnerabilitypairings.xml"))
        {
            // Creates a list of elements where each element is an attack type.
            List<XElement> xmlContent = new List<XElement>();
            while (r.Read())
            {
                switch (r.NodeType)
                {
                    case XmlNodeType.Element:
                        if (r.Name == "AttackTypes")
                            xmlContent.Add(XElement.ReadFrom(r) as XElement);
                        break;
                }
            }

            // Loops through content and builds dictionary
            foreach (var entry in xmlContent)
            {
                AttackTypes attack;
                if (!System.Enum.TryParse<AttackTypes>(entry.Attribute("key").Value, out attack))
                    break;

                _attacks.Add(attack);

                List<DefenseTypes> defenses = new List<DefenseTypes>();
                foreach (var el in entry.Elements())
                {
                    DefenseTypes defense;
                    if (!System.Enum.TryParse<DefenseTypes>(el.Value, out defense))
                        break;
                    defenses.Add(defense);

                    if (!_defenses.Contains(defense))
                        _defenses.Add(defense);
                }

                _vulnerabilityPairs.Add(attack, defenses);
            }
        }

        // Todo: Read from localization file
        _attackStringValue = new Dictionary<AttackTypes, string>
        {
            { AttackTypes.Injection, "Inject malicious code" },
            { AttackTypes.Credential_Stuffing, "Credential stuffing" },
            { AttackTypes.Package_Sniffing, "Package sniffing" },
            { AttackTypes.Hostile_XML, "Insert hostile XML" },
            { AttackTypes.Bypass_Access_Control, "Bypass access control" },
            { AttackTypes.Exploit_Sec_Mis_Config, "Exploit security missconfiguration" },
            { AttackTypes.XSS, "Cross site scripting" },
            { AttackTypes.Remote_Code_Exec, "Remote code execution" },
            { AttackTypes.Mis_Config_Systems, "Missconfigurated system" },
            { AttackTypes.Disable_Log, "Disable logging" },
        };

        _defenseStringValue = new Dictionary<DefenseTypes, string>
        {
            { DefenseTypes.Sanitize_Input, "Sanitize user input" },
            { DefenseTypes.Two_Factor_Auth, "Two factor authentication" },
            { DefenseTypes.Firewall, "Configure firewall" },
            { DefenseTypes.Patch_Update, "Patch and update code" },
            { DefenseTypes.Log_Failure, "Log failures" },
            { DefenseTypes.Update_Config, "Update config file" },
            { DefenseTypes.Esacpe_Untrusted_HTTP, "Escape untrusted HTTP request" },
            { DefenseTypes.Integrity_Check, "Check integrity" },
            { DefenseTypes.Reduce_Unused_Features, "Reduse unused features" },
            { DefenseTypes.Off_Site_Logging, "3rd party logging" },
            { DefenseTypes.Use_Safe_API, "Use a safe API" },
            { DefenseTypes.Enforce_PW_Policy, "Enforce better password policy" },
            { DefenseTypes.Encrypt_Data, "Encrypt all data" },
        };
    }

    /// <summary>
    /// Checks whether the attack is stopped by the defense.
    /// Throws an exception if the dictionary doesn't contain the attack.
    /// </summary>
    /// <param name="attack">Type of attack</param>
    /// <param name="defense">Type of defense</param>
    /// <returns>True if the defense stops the attack, else false</returns>
    public static bool IsStoppedBy(AttackTypes attack, DefenseTypes defense)
    {
        if (!_vulnerabilityPairs.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _vulnerabilityPairs[attack].Contains(defense);
    }

    /// <summary>
    /// Returns current used string by an attack type.
    /// Throws an exception if the dictionary doesn't contain the attack.
    /// </summary>
    /// <param name="attack">Attacktype to check</param>
    /// <returns>The string paired to the attack</returns>
    public static string GetAttackString(AttackTypes attack)
    {
        if (!_attackStringValue.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _attackStringValue[attack];
    }

    /// <summary>
    /// Returns current used string by a defense type.
    /// Throws and exception if the dictionary doesn't contain the defense.
    /// </summary>
    /// <param name="defense">Defensetype to check</param>
    /// <returns>The string paired to the defense</returns>
    public static string GetDefenseString(DefenseTypes defense)
    {
        if (!_defenseStringValue.ContainsKey(defense))
            throw new System.Exception("Defense doesn't exist in this context!");
        return _defenseStringValue[defense];
    }

    /// TODO:
    /// Need to either move attack list or find a better way of having a list of all attacks.
    /// Maybe have a list of defenses aswell?
    /// <summary>
    /// Returns the entire list of AttackTypes.
    /// </summary>
    /// <returns>List of AttackTypes</returns>
    public static List<AttackTypes> GetAllAttacks()
    {
        return _attacks;
    }

    public static List<DefenseTypes> GetAllDefenses()
    {
        return _defenses;
    }
}