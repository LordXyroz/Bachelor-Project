using System.Collections.Generic;

using System.Xml;
using System.Xml.Linq;
using UnityEngine;

/// <summary>
/// Static class for holding which attack is stopped by which defense.
/// Uses Dictionary with a list to create a one-to-many relationship
/// </summary>
/// 
/// TODO:
/// Try-catch for typos etc...
public static class VulnerabilityPairings
{
    private static Dictionary<AttackTypes, List<DefenseTypes>> _vulnerabilityPairs;

    private static Dictionary<AttackTypes, string> _attackStringValue;
    private static Dictionary<DefenseTypes, string> _defenseStringValue;

    private static List<AttackTypes> _attacks;
    private static List<DefenseTypes> _defenses;
    private static DefenseTypes attack;

    /// <summary>
    /// Static constructor for setting up default values of the dictionary.
    /// AttackTypes is the key, List of DefenseTypes is the value.
    /// Loads xml file, and parses its content. Uses TryParse from enum
    /// to match the string value from xml with an enum entry.
    /// </summary>
    static VulnerabilityPairings()
    {
        /// Opens the xml file to start reading from it
        using (var reader = XmlReader.Create("Assets/Resources/VulnerabilityLogic.xml"))
        {
            XElement attackStrings = null;
            XElement defenseStrings = null;
            XElement vulnerabilityPairs = null;

            /// Reads through entire xml file
            while (reader.Read())
            {
                switch (reader.NodeType)
                {
                    /// When we encounter a base element, we store them XElement
                    case XmlNodeType.Element:
                        if (reader.Name == "_AttackStrings")
                            attackStrings = XElement.ReadFrom(reader) as XElement;
                        else if (reader.Name == "_DefenseStrings")
                            defenseStrings = XElement.ReadFrom(reader) as XElement;
                        else if (reader.Name == "_VulnerabilityPairs")
                            vulnerabilityPairs = XElement.ReadFrom(reader) as XElement;
                        break;
                }
            }

            _attackStringValue = new Dictionary<AttackTypes, string>();

            /// Loops through sub-elements of _AttackStrings element, and builds the dictionary
            foreach (var element in attackStrings.Elements())
            {
                AttackTypes attack;
                if (!System.Enum.TryParse<AttackTypes>(element.Attribute("key").Value, out attack))
                    continue;

                string value = element.Element("string").Value;
                if (value == null)
                    continue;

                _attackStringValue.Add(attack, value);
            }

            _defenseStringValue = new Dictionary<DefenseTypes, string>();

            /// Loops through sub-elements of _DefenseStrings element, and builds the dictionary
            foreach (var element in defenseStrings.Elements())
            {
                DefenseTypes defense;
                if (!System.Enum.TryParse<DefenseTypes>(element.Attribute("key").Value, out defense))
                    continue;

                string value = element.Element("string").Value;
                if (value == null)
                    continue;

                _defenseStringValue.Add(defense, value);
            }

            _vulnerabilityPairs = new Dictionary<AttackTypes, List<DefenseTypes>>();
            _attacks = new List<AttackTypes>();
            _defenses = new List<DefenseTypes>();

            /// Loops through sub-elements of _VulnerabilityPairs, and builds the dictionary
            foreach (var element in vulnerabilityPairs.Elements())
            {
                AttackTypes attack;
                if (!System.Enum.TryParse<AttackTypes>(element.Attribute("key").Value, out attack))
                    break;

                _attacks.Add(attack);

                List<DefenseTypes> defenses = new List<DefenseTypes>();
                foreach (var el in element.Elements())
                {
                    DefenseTypes defense;
                    if (!System.Enum.TryParse<DefenseTypes>(el.Value, out defense))
                        break;
                    defenses.Add(defense);

                    if (!_defenses.Contains(defense))
                        _defenses.Add(defense);
                }

                _vulnerabilityPairs.Add(attack, defenses);
            }

        }
    }

    /// <summary>
    /// Checks whether the attack is stopped by the defense.
    /// Throws an exception if the dictionary doesn't contain the attack.
    /// </summary>
    /// <param name="attack">Type of attack</param>
    /// <param name="defense">Type of defense</param>
    /// <returns>True if the defense stops the attack, else false</returns>
    public static bool IsStoppedBy(AttackTypes attack, DefenseTypes defense)
    {
        if (!_vulnerabilityPairs.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _vulnerabilityPairs[attack].Contains(defense);
    }

    /// <summary>
    /// Returns current used string by an attack type.
    /// Throws an exception if the dictionary doesn't contain the attack.
    /// </summary>
    /// <param name="attack">Attacktype to check</param>
    /// <returns>The string paired to the attack</returns>
    public static string GetAttackString(AttackTypes attack)
    {
        if (!_attackStringValue.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _attackStringValue[attack];
    }

    /// <summary>
    /// Returns current used string by a defense type.
    /// Throws and exception if the dictionary doesn't contain the defense.
    /// </summary>
    /// <param name="defense">Defensetype to check</param>
    /// <returns>The string paired to the defense</returns>
    public static string GetDefenseString(DefenseTypes defense)
    {
        if (!_defenseStringValue.ContainsKey(defense))
            throw new System.Exception("Defense doesn't exist in this context!");
        return _defenseStringValue[defense];
    }

    /// TODO:
    /// Need to either move attack list or find a better way of having a list of all attacks.
    /// Maybe have a list of defenses aswell?
    /// <summary>
    /// Returns the entire list of AttackTypes.
    /// </summary>
    /// <returns>List of AttackTypes</returns>
    public static List<AttackTypes> GetAllAttacks()
    {
        return _attacks;
    }

    /// <summary>
    /// Returns the entire list of DefenseTypes.
    /// </summary>
    /// <returns>List of DefenseTypes</returns>
    public static List<DefenseTypes> GetAllDefenses()
    {
        return _defenses;
    }
}