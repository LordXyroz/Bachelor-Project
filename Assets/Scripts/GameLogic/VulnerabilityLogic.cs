using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using UnityEngine;

/// <summary>
/// Static class for holding which attack is stopped by which defense.
/// Uses Dictionary with a list to create a one-to-many relationship
/// </summary>
public static class VulnerabilityLogic
{
    private static Dictionary<AttackTypes, List<DefenseTypes>> _vulnerabilityPairs;

    private static Dictionary<AttackTypes, string> _attackStringValue;
    private static Dictionary<DefenseTypes, string> _defenseStringValue;

    private static List<AttackTypes> _attacks;
    private static List<DefenseTypes> _defenses;

    /// <summary>
    /// Static constructor for setting up default values of the dictionary.
    /// AttackTypes is the key, List of DefenseTypes is the value.
    /// Loads xml file, and parses its content. Uses TryParse from enum
    /// to match the string value from xml with an enum entry.
    /// </summary>
    static VulnerabilityLogic()
    {
        /// Loads the assetbundle that contains the xml file.
        var assetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, "Assets/AssetBundles/xml"));
        /// Loads the xml file as a text asset
        var asset = assetBundle.LoadAsset("VulnerabilityLogic.xml") as TextAsset;

        /// Creates an XmlReader from the loaded asset using string reader
        using (var reader = XmlReader.Create(new StringReader(asset.text)))
        {
            XElement attackStrings = null;
            XElement defenseStrings = null;
            XElement vulnerabilityPairs = null;

            /// Reads through entire xml file
            while (reader.Read())
            {
                switch (reader.NodeType)
                {
                    /// When we encounter a base element, we store them XElement
                    case XmlNodeType.Element:
                        if (reader.Name == "_AttackStrings")
                            attackStrings = XElement.ReadFrom(reader) as XElement;
                        else if (reader.Name == "_DefenseStrings")
                            defenseStrings = XElement.ReadFrom(reader) as XElement;
                        else if (reader.Name == "_VulnerabilityPairs")
                            vulnerabilityPairs = XElement.ReadFrom(reader) as XElement;
                        break;
                }
            }

            _attackStringValue = new Dictionary<AttackTypes, string>();

            /// Loops through sub-elements of _AttackStrings element, and builds the dictionary
            foreach (var element in attackStrings.Elements())
            {
                AttackTypes attack;
                if (!System.Enum.TryParse<AttackTypes>(element.Attribute("key").Value, out attack))
                    continue;


                string value = element.Element("string").Value;
                if (value == null)
                    continue;

                _attackStringValue.Add(attack, value);
            }

            _defenseStringValue = new Dictionary<DefenseTypes, string>();

            /// Loops through sub-elements of _DefenseStrings element, and builds the dictionary
            foreach (var element in defenseStrings.Elements())
            {
                DefenseTypes defense;
                if (!System.Enum.TryParse<DefenseTypes>(element.Attribute("key").Value, out defense))
                    continue;

                string value = element.Element("string").Value;
                if (value == null)
                    continue;

                _defenseStringValue.Add(defense, value);
            }

            _vulnerabilityPairs = new Dictionary<AttackTypes, List<DefenseTypes>>();
            _attacks = new List<AttackTypes>();
            _defenses = new List<DefenseTypes>();

            /// Loops through sub-elements of _VulnerabilityPairs, and builds the dictionary
            foreach (var element in vulnerabilityPairs.Elements())
            {
                AttackTypes attack;
                if (!System.Enum.TryParse<AttackTypes>(element.Attribute("key").Value, out attack))
                    continue;

                _attacks.Add(attack);

                List<DefenseTypes> defenses = new List<DefenseTypes>();
                foreach (var el in element.Elements())
                {
                    DefenseTypes defense;
                    if (!System.Enum.TryParse<DefenseTypes>(el.Value, out defense))
                        continue;
                    defenses.Add(defense);

                    if (!_defenses.Contains(defense))
                        _defenses.Add(defense);
                }

                _vulnerabilityPairs.Add(attack, defenses);
            }
        }
    }

    /// <summary>
    /// Checks whether the attack is stopped by the defense.
    /// Throws an exception if the dictionary doesn't contain the attack.
    /// </summary>
    /// <param name="attack">Type of attack</param>
    /// <param name="defense">Type of defense</param>
    /// <returns>True if the defense stops the attack, else false</returns>
    public static bool IsStoppedBy(AttackTypes attack, DefenseTypes defense)
    {
        if (!_vulnerabilityPairs.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _vulnerabilityPairs[attack].Contains(defense);
    }

    /// <summary>
    /// Returns current used string by an attack type.
    /// Throws an exception if the dictionary doesn't contain the attack.
    /// </summary>
    /// <param name="attack">Attacktype to check</param>
    /// <returns>The string paired to the attack</returns>
    public static string GetAttackString(AttackTypes attack)
    {
        if (!_attackStringValue.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _attackStringValue[attack];
    }

    /// <summary>
    /// Returns the key from a string if it exists in the attack dictionary.
    /// </summary>
    /// <param name="attack">String value of an attack</param>
    /// <returns>Key paired to the string</returns>
    public static AttackTypes GetAttackFromString(string attack)
    {
        if (!_attackStringValue.ContainsValue(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _attackStringValue.Where(x => x.Value == attack).First().Key;
    }

    /// <summary>
    /// Returns current used string by a defense type.
    /// Throws and exception if the dictionary doesn't contain the defense.
    /// </summary>
    /// <param name="defense">Defensetype to check</param>
    /// <returns>The string paired to the defense</returns>
    public static string GetDefenseString(DefenseTypes defense)
    {
        if (!_defenseStringValue.ContainsKey(defense))
            throw new System.Exception("Defense doesn't exist in this context!");
        return _defenseStringValue[defense];
    }

    /// <summary>
    /// Returns the key from a string if it exists in the defense dictionary.
    /// </summary>
    /// <param name="defense">String value of a defense</param>
    /// <returns>key paried to the defense</returns>
    public static DefenseTypes GetDefenseFromString(string defense)
    {
        if (!_defenseStringValue.ContainsValue(defense))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _defenseStringValue.Where(x => x.Value == defense).First().Key;
    }

    /// TODO:
    /// Need to either move attack list or find a better way of having a list of all attacks.
    /// Maybe have a list of defenses aswell?
    /// <summary>
    /// Returns the entire list of AttackTypes.
    /// </summary>
    /// <returns>List of AttackTypes</returns>
    public static List<AttackTypes> GetAllAttacks()
    {
        return _attacks;
    }

    /// <summary>
    /// Returns the entire list of DefenseTypes.
    /// </summary>
    /// <returns>List of DefenseTypes</returns>
    public static List<DefenseTypes> GetAllDefenses()
    {
        return _defenses;
    }

    /// <summary>
    /// Returns a list of defenses that can stop an attack.
    /// </summary>
    /// <param name="attack">Attack to be checked</param>
    /// <returns>List of defenses that stop the attack</returns>
    public static List<DefenseTypes> GetDefenses(AttackTypes attack)
    {
        if (!_vulnerabilityPairs.ContainsKey(attack))
            throw new System.Exception("Attack doesn't exist in this context!");
        return _vulnerabilityPairs[attack];
    }
}